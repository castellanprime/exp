%%
%% Copyright (c) 2018 Vitor Enes.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

-module(exp_overlay).
-author("Vitor Enes <vitorenesduarte@gmail.com").

-include("exp.hrl").

-export([get/2,
         numerical_id_and_neighbors/3]).

%% @doc The first argument can be:
%%          - `ring'
%%          - `fullmesh'
%%          - `line'
%%      The second argument is the number of nodes.
-spec get(atom(), pos_integer()) -> orddict:orddict().
get(_, 1) ->
    [];
get(fullmesh, N) ->
    All = lists:seq(0, N - 1),
    lists:foldl(
        fun(I, Acc) ->
            orddict:store(I, All -- [I], Acc)
        end,
        orddict:new(),
        All
    );
get(tree, 14) ->
    %% automatically generated by topologies.py
    [{0, [6]}, {1, [5, 11, 10]}, {2, [7]}, {3, [7]}, {4, [6]}, {5, [1]}, {6, [0, 4, 11]}, {7, [3, 2, 12]}, {8, [9]}, {9, [12, 13, 8]}, {10, [1]}, {11, [1, 12, 6]}, {12, [9, 7, 11]}, {13, [9]}];
get(tree, 15) ->
    %% automatically generated by topologies.py
    [{0, [1, 8, 13]}, {1, [0, 6]}, {2, [5]}, {3, [10]}, {4, [5]}, {5, [4, 6, 2]}, {6, [1, 10, 5]}, {7, [13]}, {8, [9, 0, 14]}, {9, [8]}, {10, [12, 3, 6]}, {11, [13]}, {12, [10]}, {13, [11, 0, 7]}, {14, [8]}];
get(partialmesh, 8) ->
    [{0, [1, 7, 4]}, {1, [0, 2, 5]}, {2, [1, 6, 3]}, {3, [2, 7, 4]}, {4, [5, 0, 3]}, {5, [6, 4, 1]}, {6, [5, 2, 7]}, {7, [6, 0, 3]}];
get(partialmesh, 15) ->
    [{0, [14, 11, 4, 1]}, {1, [2, 5, 0, 12]}, {2, [1, 13, 6, 3]}, {3, [7, 14, 2, 4]}, {4, [8, 0, 5, 3]}, {5, [9, 6, 1, 4]}, {6, [5, 7, 10, 2]}, {7, [3, 11, 6, 8]}, {8, [4, 9, 12, 7]}, {9, [5, 8, 10, 13]}, {10, [11, 6, 9, 14]}, {11, [10, 7, 0, 12]}, {12, [13, 11, 1, 8]}, {13, [12, 2, 9, 14]}, {14, [0, 3, 13, 10]}];
get(partialmesh, 16) ->
    %% automatically generated by topologies.py
    [{0, [15, 4, 12, 1]}, {1, [2, 5, 13, 0]}, {2, [1, 6, 3, 14]}, {3, [15, 7, 2, 4]}, {4, [8, 0, 5, 3]}, {5, [6, 1, 4, 9]}, {6, [5, 7, 10, 2]}, {7, [3, 11, 6, 8]}, {8, [4, 9, 12, 7]}, {9, [8, 13, 5, 10]}, {10, [11, 6, 9, 14]}, {11, [10, 7, 12, 15]}, {12, [13, 0, 11, 8]}, {13, [12, 9, 1, 14]}, {14, [15, 2, 13, 10]}, {15, [3, 0, 14, 11]}];
get(partialmesh, 32) ->
    [{0, [28, 4, 1, 31]}, {1, [2, 5, 29, 0]}, {2, [1, 30, 6, 3]}, {3, [7, 31, 2, 4]}, {4, [8, 0, 5, 3]}, {5, [9, 6, 1, 4]}, {6, [10, 5, 7, 2]}, {7, [11, 3, 6, 8]}, {8, [4, 9, 12, 7]}, {9, [5, 8, 13, 10]}, {10, [6, 11, 9, 14]}, {11, [10, 7, 12, 15]}, {12, [16, 13, 11, 8]}, {13, [17, 12, 9, 14]}, {14, [15, 13, 18, 10]}, {15, [14, 19, 16, 11]}, {16, [12, 17, 15, 20]}, {17, [21, 13, 16, 18]}, {18, [22, 19, 17, 14]}, {19, [18, 20, 15, 23]}, {20, [19, 21, 24, 16]}, {21, [17, 20, 22, 25]}, {22, [18, 26, 21, 23]}, {23, [24, 27, 22, 19]}, {24, [23, 28, 20, 25]}, {25, [26, 21, 24, 29]}, {26, [25, 22, 30, 27]}, {27, [23, 28, 31, 26]}, {28, [29, 0, 27, 24]}, {29, [28, 30, 1, 25]}, {30, [2, 29, 26, 31]}, {31, [3, 30, 27, 0]}];
get(partialmesh, 49) ->
    [{0, [4, 45, 1, 48]}, {1, [5, 46, 2, 0]}, {2, [6, 47, 3, 1]}, {3, [7, 2, 4, 48]}, {4, [0, 8, 3, 5]}, {5, [1, 9, 6, 4]}, {6, [7, 2, 10, 5]}, {7, [8, 3, 6, 11]}, {8, [7, 12, 9, 4]}, {9, [8, 13, 5, 10]}, {10, [14, 6, 11, 9]}, {11, [15, 7, 12, 10]}, {12, [8, 13, 11, 16]}, {13, [17, 12, 9, 14]}, {14, [18, 15, 10, 13]}, {15, [14, 16, 19, 11]}, {16, [17, 15, 12, 20]}, {17, [13, 16, 21, 18]}, {18, [19, 14, 17, 22]}, {19, [18, 23, 15, 20]}, {20, [24, 16, 19, 21]}, {21, [17, 25, 22, 20]}, {22, [23, 26, 18, 21]}, {23, [19, 22, 24, 27]}, {24, [28, 23, 25, 20]}, {25, [26, 24, 29, 21]}, {26, [25, 22, 30, 27]}, {27, [31, 28, 23, 26]}, {28, [32, 24, 29, 27]}, {29, [30, 33, 28, 25]}, {30, [29, 26, 31, 34]}, {31, [35, 27, 30, 32]}, {32, [28, 36, 33, 31]}, {33, [34, 29, 32, 37]}, {34, [38, 33, 35, 30]}, {35, [31, 36, 34, 39]}, {36, [37, 35, 32, 40]}, {37, [36, 41, 38, 33]}, {38, [34, 37, 39, 42]}, {39, [38, 35, 40, 43]}, {40, [41, 39, 36, 44]}, {41, [40, 37, 45, 42]}, {42, [38, 43, 41, 46]}, {43, [42, 44, 39, 47]}, {44, [45, 43, 48, 40]}, {45, [44, 0, 41, 46]}, {46, [47, 45, 1, 42]}, {47, [2, 46, 48, 43]}, {48, [3, 47, 44, 0]}];
get(partialmesh, 50) ->
[{0, [4, 49, 46, 1]}, {1, [5, 47, 2, 0]}, {2, [48, 6, 3, 1]}, {3, [7, 49, 2, 4]}, {4, [0, 8, 3, 5]}, {5, [1, 9, 6, 4]}, {6, [7, 2, 10, 5]}, {7, [8, 3, 6, 11]}, {8, [7, 12, 4, 9]}, {9, [13, 8, 5, 10]}, {10, [14, 6, 11, 9]}, {11, [15, 7, 12, 10]}, {12, [8, 13, 11, 16]}, {13, [17, 12, 9, 14]}, {14, [18, 15, 10, 13]}, {15, [14, 16, 19, 11]}, {16, [17, 15, 12, 20]}, {17, [13, 16, 21, 18]}, {18, [19, 14, 17, 22]}, {19, [18, 23, 15, 20]}, {20, [24, 16, 19, 21]}, {21, [17, 25, 22, 20]}, {22, [23, 26, 18, 21]}, {23, [19, 22, 24, 27]}, {24, [28, 23, 25, 20]}, {25, [26, 24, 29, 21]}, {26, [25, 22, 30, 27]}, {27, [31, 28, 23, 26]}, {28, [32, 24, 29, 27]}, {29, [30, 33, 28, 25]}, {30, [29, 26, 31, 34]}, {31, [35, 27, 30, 32]}, {32, [28, 36, 33, 31]}, {33, [34, 29, 32, 37]}, {34, [38, 33, 35, 30]}, {35, [31, 36, 34, 39]}, {36, [37, 35, 32, 40]}, {37, [36, 41, 38, 33]}, {38, [34, 37, 39, 42]}, {39, [38, 35, 40, 43]}, {40, [41, 39, 36, 44]}, {41, [40, 37, 45, 42]}, {42, [38, 43, 41, 46]}, {43, [42, 44, 39, 47]}, {44, [45, 43, 48, 40]}, {45, [44, 41, 46, 49]}, {46, [47, 45, 0, 42]}, {47, [46, 1, 48, 43]}, {48, [2, 47, 44, 49]}, {49, [0, 3, 45, 48]}];
get(partialmesh, 64) ->
    [{0, [4, 63, 60, 1]}, {1, [5, 2, 0, 61]}, {2, [6, 3, 62, 1]}, {3, [7, 2, 4, 63]}, {4, [0, 5, 8, 3]}, {5, [4, 1, 9, 6]}, {6, [7, 2, 10, 5]}, {7, [8, 3, 6, 11]}, {8, [7, 12, 9, 4]}, {9, [8, 13, 5, 10]}, {10, [14, 6, 11, 9]}, {11, [15, 7, 12, 10]}, {12, [8, 13, 11, 16]}, {13, [17, 12, 9, 14]}, {14, [18, 15, 10, 13]}, {15, [14, 11, 16, 19]}, {16, [17, 15, 12, 20]}, {17, [13, 16, 21, 18]}, {18, [19, 14, 17, 22]}, {19, [18, 15, 23, 20]}, {20, [24, 16, 19, 21]}, {21, [17, 25, 22, 20]}, {22, [23, 26, 18, 21]}, {23, [22, 19, 24, 27]}, {24, [28, 23, 25, 20]}, {25, [26, 24, 29, 21]}, {26, [25, 22, 30, 27]}, {27, [31, 28, 23, 26]}, {28, [32, 24, 29, 27]}, {29, [30, 33, 28, 25]}, {30, [29, 26, 31, 34]}, {31, [35, 27, 30, 32]}, {32, [28, 36, 33, 31]}, {33, [34, 29, 32, 37]}, {34, [38, 33, 35, 30]}, {35, [31, 36, 34, 39]}, {36, [37, 35, 32, 40]}, {37, [36, 41, 33, 38]}, {38, [34, 39, 42, 37]}, {39, [38, 35, 40, 43]}, {40, [41, 39, 36, 44]}, {41, [40, 37, 45, 42]}, {42, [38, 43, 41, 46]}, {43, [42, 44, 47, 39]}, {44, [45, 43, 48, 40]}, {45, [44, 41, 49, 46]}, {46, [47, 45, 50, 42]}, {47, [51, 46, 48, 43]}, {48, [52, 47, 44, 49]}, {49, [45, 50, 53, 48]}, {50, [51, 49, 46, 54]}, {51, [52, 47, 50, 55]}, {52, [51, 48, 56, 53]}, {53, [54, 52, 49, 57]}, {54, [55, 58, 53, 50]}, {55, [54, 56, 59, 51]}, {56, [55, 52, 60, 57]}, {57, [61, 53, 58, 56]}, {58, [54, 59, 62, 57]}, {59, [58, 55, 60, 63]}, {60, [59, 0, 56, 61]}, {61, [57, 62, 60, 1]}, {62, [61, 2, 58, 63]}, {63, [0, 3, 59, 62]}];
get(ring, N) ->
    lists:foldl(
        fun(I, Acc) ->
            Peers = [
                previous(I, N),
                next(I, N)
            ],
            orddict:store(I, Peers, Acc)
        end,
        orddict:new(),
        lists:seq(0, N - 1)
    );
get(line, N) ->
    T0 = get(ring, N),
    First = 0,
    Last = N - 1,
    T1 = lists:keyreplace(
        First,
        1,
        T0,
        {First, [next(First, N)]}
    ),
    T2 = lists:keyreplace(
        Last,
        1,
        T1,
        {Last, [previous(Last, N)]}
    ),
    T2.


%% @doc The first argument is my node spec,
%%      the second argument is a list of node specs,
%%      and the third argument is the overlay.
-spec numerical_id_and_neighbors(ldb_node_id(), list(node_spec()), atom()) ->
    {non_neg_integer(), list(node_spec())}.
numerical_id_and_neighbors(MyName, Nodes, Overlay) ->
    NodeNumber = length(Nodes),
    Sorted = lists:sort(Nodes),

    NumericalId = numerical_id(MyName, Sorted),

    %% id -> [id]
    Topology = get(Overlay, NodeNumber),

    {NumericalId, [lists:nth(I + 1, Sorted) || I <- orddict:fetch(NumericalId, Topology)]}.

%% @private Get numerical id, given the name a list of sorted specs by name.
-spec numerical_id(ldb_node_id(), list(node_spec())) -> non_neg_integer().
numerical_id(MyName, Sorted) ->
    %% compute id
    lists:foldl(
        fun({Name, _, _}, Acc) ->
            case Name < MyName of
                true ->
                    Acc + 1;
                false ->
                    Acc
            end
        end,
        0,
        Sorted
    ).

%% @private
previous(I, N) ->
    First = 0,
    case I of
        First ->
            N - 1;
        _ ->
            I - 1
    end.

%% @private
next(I, N) ->
    Last = N - 1,
    case I of
        Last ->
            0;
        _ ->
            I + 1
    end.
